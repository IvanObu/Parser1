from gc import callbacks
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, BufferedInputFile, FSInputFile
from aiogram import Bot, Dispatcher, F, Router
from aiogram.filters import CommandStart, Command
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from Db.main_db import find_products_by_params, add_to_my_list, is_in_my_list, get_my_list
from Graphics.main_graphic import generate_price_graph

import sqlite3

import Aio.App.keyboards as kb

route = Router()

class Reg(StatesGroup):
    name = State()
    number = State()

class FilterFSM(StatesGroup):
    choosing_series = State()
    choosing_model = State()
    choosing_memory = State()
    choosing_color = State()
    waiting_for_search_text = State()

class FilterMFSM(StatesGroup):
    choosing_series = State()
    choosing_model = State()
    choosing_cpu = State()
    choosing_ram = State()
    choosing_storage = State()
    choosing_color = State()
    waiting_for_search_text = State()

class ProfileStates(StatesGroup):
    changing_name = State()

async def is_user_registered(user_id: int, conn: sqlite3.Connection) -> bool:
    cursor = conn.cursor()
    cursor.execute("SELECT 1 FROM User WHERE rowid = ?", (user_id,))
    return cursor.fetchone() is not None

async def update_user_name(user_id: int, name: str, conn: sqlite3.Connection):
    cursor = conn.cursor()
    cursor.execute("INSERT OR REPLACE INTO User (rowid, Name) VALUES (?, ?)", (user_id, name))
    conn.commit()

@route.message(CommandStart())
async def cmd_start(message: Message):
    user_id = message.from_user.id
    user_name = message.from_user.full_name

    with sqlite3.connect("Db/products.db") as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT Name FROM User WHERE Us_Id = ?", (user_id,))
        user = cursor.fetchone()

        if not user:
            cursor.execute("INSERT INTO User (Us_Id, Name) VALUES (?, ?)", (user_id, user_name))
            conn.commit()
            name = user_name
        else:
            name = user[0]
        if name:
            await message.answer(
                f"üñê Welcome back, {name}!",
                reply_markup=kb.main_kb
            )
        else:
            await message.answer(
                "üëã Welcome! Use /reg command to register.",
                reply_markup=kb.main_kb
            )

@route.message(Command("reg"))
async def cmd_reg(message: Message, state: FSMContext):
    with sqlite3.connect("Db/products.db") as conn:
        if await is_user_registered(message.from_user.id, conn):
            cursor = conn.cursor()
            cursor.execute("SELECT Name FROM User WHERE rowid = ?", (message.from_user.id,))
            name = cursor.fetchone()[0]
            await message.answer(
                f"You're already registered as {name}.\n"
                "You can change your name in settings.",
                reply_markup=kb.main_kb
            )
        else:
            await message.answer(
                "üìù Please enter your name:",
                reply_markup=kb.cancel_kb
            )
            await state.set_state(ProfileStates.changing_name)

@route.message(F.text == "‚öôÔ∏è Settings")
async def settings_menu(message: Message):
    await message.answer(
        "‚öôÔ∏è Settings menu:",
        reply_markup=kb.settings_kb
    )

@route.message(F.text == "‚úèÔ∏è –°–º–µ–Ω–∞ –∏–º–µ–Ω–∏")
async def start_change_name(message: Message, state: FSMContext):
    await message.answer(
        "üìù Enter new name:",
        reply_markup=kb.cancel_kb
    )
    await state.set_state(ProfileStates.changing_name)

@route.message(ProfileStates.changing_name, F.text)
async def process_name(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await state.clear()
        await message.answer("Action canceled", reply_markup=kb.main_kb)
        return

    if len(message.text) > 100:
        await message.answer("Name too long (max 100 chars)")
        return

    with sqlite3.connect("Db/products.db") as conn:
        await update_user_name(message.from_user.id, message.text, conn)
        await message.answer(
            f"‚úÖ –ò–º—è –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞: {message.text}",
            reply_markup=kb.main_kb
        )
    await state.clear()

@route.message(F.text == "Ô∏è‚Ü©Ô∏è –ù–∞–∑–∞–¥")
async def back_to_main(message: Message):
    await message.answer(
        "Main menu:",
        reply_markup=kb.main_kb
    )

@route.message(F.text == "üîé Search")
async def start_search(message: Message):
    await message.answer("Search üîé", reply_markup=kb.ReplyKeyboardRemove())
    await message.answer("choose category:", reply_markup=kb.search_kb)

@route.message(F.text == "üìò Instruction")
async def instruction_handler(message: Message):
    await message.answer(
        text="üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞...\n[–û–ø–∏—Å–∞–Ω–∏–µ]:",
        reply_markup=kb.back
    )

@route.callback_query(F.data == "back_main")
async def back_main_handler(callback: CallbackQuery):
    await callback.message.edit_reply_markup(reply_markup=None)
    await callback.message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=kb.main_kb)
    await callback.answer()

@route.message(F.text == "üì¶ About shops")
async def about_stores_handler(message: Message):
    await message.answer("üè¨ –û–ø–∏—Å–∞–Ω–∏–µ –º–∞–≥–∞–∑–∏–Ω–æ–≤:\n[–ó–¥–µ—Å—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è]", reply_markup=kb.back)

@route.message(F.text == "üìÅ Make exel file")
async def send_excel_file(message: Message):
    try:

        file_path = "Db/apple_products.xlsx"
        file = FSInputFile(file_path, filename="–û—Ç—á–µ—Ç.xlsx")
        await message.answer_document(
            document=file,
            caption="–í–∞—à Excel-—Ñ–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏ üìä"
        )
    except FileNotFoundError:
        await message.answer("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω üò¢")
    except Exception as e:
        await message.answer(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

@route.message(F.text == "‚öôÔ∏è Settings")
async def start_search(message: Message):
    await message.answer("Search üîé", reply_markup=kb.ReplyKeyboardRemove())
    await message.answer("choose category:", reply_markup=kb.search_kb)

@route.message(Command("help"))
async def cmd_start(message: Message):
    await message.answer(
        text="üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞...\n[–û–ø–∏—Å–∞–Ω–∏–µ]:",
        reply_markup=kb.back
    )



@route.callback_query( F.data== "back_main")
async def back_to_main_menu(callback: CallbackQuery):
    await callback.message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=kb.main_kb)
    await callback.answer()

@route.callback_query( F.data== "end_search")
async def back_to_main_menu(callback: CallbackQuery):
    await callback.message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=kb.main_kb)
    await callback.answer()

@route.message(Reg.name)
async def reg_two(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(Reg.number)
    await message.answer("Enter your number:")

@route.callback_query(F.data == "device_iphone")
async def handle_device_iphone(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–∏—é iPhone:", reply_markup=kb.get_series_kb())
    await state.set_state(FilterFSM.choosing_series)

@route.callback_query(F.data.startswith("series_"))
async def choose_model(callback: CallbackQuery, state: FSMContext):
    series = callback.data.split("_", 1)[1]
    await state.update_data(series=series)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:", reply_markup=kb.get_model_kb(series))
    await state.set_state(FilterFSM.choosing_model)

@route.callback_query(F.data.startswith("model_"))
async def choose_memory(callback: CallbackQuery, state: FSMContext):
    model = callback.data.split("_", 1)[1]
    data = await state.get_data()
    series = data["series"]
    await state.update_data(model=model)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–º –ø–∞–º—è—Ç–∏:", reply_markup=kb.get_memory_kb(series, model))
    await state.set_state(FilterFSM.choosing_memory)

@route.callback_query(F.data.startswith("memory_"))
async def choose_color(callback: CallbackQuery, state: FSMContext):
    memory = callback.data.split("_", 1)[1]
    data = await state.get_data()
    series = data["series"]
    model = data["model"]
    await state.update_data(memory=memory)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç:", reply_markup=kb.get_color_kb(series, model))
    await state.set_state(FilterFSM.choosing_color)

@route.callback_query(F.data.startswith("color_"))
async def confirm_selection(callback: CallbackQuery, state: FSMContext):
    color = callback.data.split("_", 1)[1]
    await state.update_data(color=color)
    await callback.message.edit_text("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≤—ã–±–æ—Ä:", reply_markup=kb.confirm_selection_kb)

@route.callback_query(F.data == "c_finish")
async def finish_selection(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    model = data["model"]
    memory = data["memory"]
    color = data["color"]

    await callback.message.edit_reply_markup()
    await callback.message.answer(
        f"‚úÖ –í—ã –≤—ã–±—Ä–∞–ª–∏:\nüì± iPhone {model}\nüíæ –ü–∞–º—è—Ç—å: {memory}\nüé® –¶–≤–µ—Ç: {color}"
    )

    filters = {
        "model": model,
        "memory": memory,
        "color": color
    }
    conn = sqlite3.connect("Db/products.db")
    products = find_products_by_params(category="iPhone", filters=filters, conn=conn)

    if not products:
        await callback.message.answer("‚ùå –¢–æ–≤–∞—Ä—ã –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.", reply_markup=kb.search_kb)
    else:
        for product in products:
            await show_product(callback, product)
        await callback.message.answer("üîç –ó–∞–≤–µ—Ä—à–∏—Ç—å –ø–æ–∏—Å–∫", reply_markup=kb.end_search_kb)
    conn.close()
    await state.clear()


@route.callback_query(F.data == "device_mac")
async def handle_device_mac(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–∏—é MacBook:", reply_markup=kb.get_mac_series_kb())
    await state.set_state(FilterMFSM.choosing_series)


@route.callback_query(F.data.startswith("mac_series_"))
async def choose_mac_model(callback: CallbackQuery, state: FSMContext):
    series = callback.data.split("_", 2)[2]
    await state.update_data(series=series)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:", reply_markup=kb.get_mac_model_kb(series))
    await state.set_state(FilterMFSM.choosing_model)


@route.callback_query(F.data.startswith("mac_model_"))
async def choose_mac_cpu(callback: CallbackQuery, state: FSMContext):
    model = callback.data.split("_", 2)[2]
    data = await state.get_data()
    series = data["series"]
    await state.update_data(model=model)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä:", reply_markup=kb.get_mac_cpu_kb(series, model))
    await state.set_state(FilterMFSM.choosing_cpu)


@route.callback_query(F.data.startswith("mac_cpu_"))
async def choose_mac_ram(callback: CallbackQuery, state: FSMContext):
    cpu = callback.data.split("_", 2)[2]
    data = await state.get_data()
    series = data["series"]
    model = data["model"]
    await state.update_data(cpu=cpu)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–º –û–ó–£:", reply_markup=kb.get_mac_ram_kb(series, model))
    await state.set_state(FilterMFSM.choosing_ram)


@route.callback_query(F.data.startswith("mac_ram_"))
async def choose_mac_storage(callback: CallbackQuery, state: FSMContext):
    ram = callback.data.split("_", 2)[2]
    data = await state.get_data()
    series = data["series"]
    model = data["model"]
    await state.update_data(ram=ram)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ–±—ä–µ–º –ø–∞–º—è—Ç–∏:", reply_markup=kb.get_mac_storage_kb(series, model))
    await state.set_state(FilterMFSM.choosing_storage)


@route.callback_query(F.data.startswith("mac_storage_"))
async def choose_mac_color(callback: CallbackQuery, state: FSMContext):
    storage = callback.data.split("_", 2)[2]
    data = await state.get_data()
    series = data["series"]
    model = data["model"]
    await state.update_data(storage=storage)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç:", reply_markup=kb.get_mac_color_kb(series, model))
    await state.set_state(FilterMFSM.choosing_color)


@route.callback_query(F.data.startswith("mac_color_"))
async def confirm_mac_selection(callback: CallbackQuery, state: FSMContext):
    color = callback.data.split("_", 2)[2]
    await state.update_data(color=color)
    data = await state.get_data()

    await callback.message.edit_text(
        f"‚úÖ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—ã–±—Ä–∞–Ω–Ω—ã–π MacBook:\n\n"
        f"–°–µ—Ä–∏—è: {data['series']}\n"
        f"–ú–æ–¥–µ–ª—å: {data['model']}\n"
        f"–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä: {data['cpu']}\n"
        f"–û–ó–£: {data['ram']}\n"
        f"–ü–∞–º—è—Ç—å: {data['storage']}\n"
        f"–¶–≤–µ—Ç: {color}\n\n"
        "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≤—ã–±–æ—Ä:",
        reply_markup=kb.confirm_mac_selection_kb()
    )


@route.callback_query(F.data == "c_finish_mac")
async def finish_mac_selection(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()

    await callback.message.edit_reply_markup()
    await callback.message.answer(
        f"‚úÖ –í—ã –≤—ã–±—Ä–∞–ª–∏ MacBook:\n"
        f"üíª {data['series']} {data['model']}\n"
        f"‚ö° –ü—Ä–æ—Ü–µ—Å—Å–æ—Ä: {data['cpu']}\n"
        f"üß† –û–ó–£: {data['ram']}\n"
        f"üíæ –ü–∞–º—è—Ç—å: {data['storage']}\n"
        f"üé® –¶–≤–µ—Ç: {data['color']}",
    )

    filters = {
        "series": data["series"],
        "model": data["model"],
        "cpu": data["cpu"],
        "ram": data["ram"],
        "storage": data["storage"],
        "color": data["color"]
    }
    conn = sqlite3.connect("Db/products.db")
    products = find_products_by_params(category="Mac", filters=filters, conn=conn)

    if not products:
        await callback.message.answer("‚ùå –¢–æ–≤–∞—Ä—ã –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.", reply_markup=kb.search_kb)
    else:
        for product in products:
            await show_product(callback, product)
        await callback.message.answer("üîç –ó–∞–≤–µ—Ä—à–∏—Ç—å –ø–æ–∏—Å–∫", reply_markup=kb.end_search_kb)
    conn.close()
    await state.clear()


async def show_product(callback, product):
    text = (
        f"üè¨ –ú–∞–≥–∞–∑–∏–Ω: {product['store']}\n"
        f"üí∞ –¶–µ–Ω–∞: {product['price']} ‚ÇΩ"
    )
    conn = sqlite3.connect("Db/products.db")
    in_list = is_in_my_list(product["product_id"], conn)

    if in_list:
        button = InlineKeyboardButton(text="‚úÖ –í —Å–ø–∏—Å–∫–µ", callback_data="none")
    else:
        button = InlineKeyboardButton(text="‚ûï –í –º–æ–π —Å–ø–∏—Å–æ–∫", callback_data=f"add_{product['product_id']}")

    keyboard = InlineKeyboardMarkup(inline_keyboard=[[button]])

    await callback.message.answer(text, reply_markup=keyboard)


@route.callback_query(F.data.startswith("add_"))
async def handle_add_to_my_list(callback: CallbackQuery):
    product_id = int(callback.data.split("_")[1])
    conn = sqlite3.connect("Db/products.db")
    add_to_my_list(product_id, conn)
    await callback.answer(text="‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –º–æ–π —Å–ø–∏—Å–æ–∫", show_alert=False)

    new_keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="‚úÖ –í —Å–ø–∏—Å–∫–µ", callback_data="none")]
        ]
    )

    try:
        await callback.message.edit_reply_markup(reply_markup=new_keyboard)
    except:
        pass


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è —É–¥–∞–ª—è–µ–º—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤
pending_changes = {}

@route.callback_query(F.data == "my_list")
async def show_my_list_handler(callback: CallbackQuery):
    conn = sqlite3.connect("Db/products.db")
    try:
        products = await get_my_list(conn)

        if not products:
            await callback.message.answer("–í–∞—à —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç", reply_markup=kb.main_kb)
            return

        pending_changes.pop(callback.from_user.id, None)

        await callback.message.answer("\nüìã –í–∞—à —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤:", reply_markup=kb.main_kb)

        for product in products:
            message_text = (
                f"üìå {product['model']}\n"
                f"üè∑ –¶–µ–Ω–∞: {product['price']} ‚ÇΩ\n"
                f"üõí –ú–∞–≥–∞–∑–∏–Ω: {product['store']}\n"
                f"üìÖ –û–±–Ω–æ–≤–ª–µ–Ω–æ: {product['price_date']}"
            )

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–∫–æ–Ω–∫—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞—Ç—É—Å–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
            notice_icon = "üîî" if product['notice_status'] == 1 else "üîï"

            keyboard = InlineKeyboardMarkup(
                inline_keyboard=[
                    [
                        InlineKeyboardButton(
                            text="‚ùå –£–¥–∞–ª–∏—Ç—å",
                            callback_data=f"mark_remove_{product['id']}"
                        ),
                        InlineKeyboardButton(
                            text=f"{notice_icon} –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è",
                            callback_data=f"notify_{product['id']}"
                        ),
                        InlineKeyboardButton(
                            text="üìà –ò—Å—Ç–æ—Ä–∏—è —Ü–µ–Ω",
                            callback_data=f"graph_{product['id']}"
                        )
                    ]
                ]
            )

            await callback.message.answer(message_text, reply_markup=keyboard)

        confirm_keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(text="‚úÖ –ü—Ä–∏–Ω—è—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è", callback_data="confirm_changes")],
                [InlineKeyboardButton(text="üîç –ó–∞–≤–µ—Ä—à–∏—Ç—å –ø–æ–∏—Å–∫", callback_data="end_search")]
            ]
        )

        await callback.message.answer("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:", reply_markup=confirm_keyboard)

    except Exception as e:
        await callback.message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ø–∏—Å–∫–∞")
    finally:
        conn.close()
    await callback.answer()


@route.callback_query(F.data.startswith("mark_remove_"))
async def mark_for_removal_handler(callback: CallbackQuery):
    try:
        product_id = int(callback.data.split("_")[2])
        user_id = callback.from_user.id

        if user_id not in pending_changes:
            pending_changes[user_id] = {"to_remove": set(), "to_restore": set()}

        pending_changes[user_id]["to_remove"].add(product_id)
        pending_changes[user_id]["to_restore"].discard(product_id)

        new_keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="‚ö†Ô∏è –ë—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–æ",
                        callback_data="none"
                    ),
                    InlineKeyboardButton(
                        text="‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å",
                        callback_data=f"unmark_remove_{product_id}"
                    )
                ]
            ]
        )

        await callback.message.edit_reply_markup(reply_markup=new_keyboard)
        await callback.answer("–¢–æ–≤–∞—Ä –æ—Ç–º–µ—á–µ–Ω –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è (–∏–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è)")

    except Exception as e:
        await callback.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ—Ç–∫–µ —Ç–æ–≤–∞—Ä–∞", show_alert=True)


@route.callback_query(F.data.startswith("unmark_remove_"))
async def unmark_removal_handler(callback: CallbackQuery):
    try:
        product_id = int(callback.data.split("_")[2])
        user_id = callback.from_user.id

        if user_id in pending_changes:
            pending_changes[user_id]["to_remove"].discard(product_id)

        new_keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="‚ùå –£–¥–∞–ª–∏—Ç—å",
                        callback_data=f"mark_remove_{product_id}"
                    ),
                    InlineKeyboardButton(
                        text="üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è",
                        callback_data=f"notify_{product_id}"
                    ),
                    InlineKeyboardButton(
                        text="üìà –ò—Å—Ç–æ–∏—Ä—è —Ü–µ–Ω",
                        callback_data=f"graph_{product_id}"
                    )
                ]
            ]
        )

        await callback.message.edit_reply_markup(reply_markup=new_keyboard)
        await callback.answer("–£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ")

    except Exception as e:
        await callback.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ —É–¥–∞–ª–µ–Ω–∏—è", show_alert=True)


@route.callback_query(F.data == "confirm_changes")
async def confirm_changes_handler(callback: CallbackQuery):
    user_id = callback.from_user.id
    try:
        if user_id in pending_changes and (
                pending_changes[user_id]["to_remove"] or pending_changes[user_id]["to_restore"]):
            with sqlite3.connect("Db/products.db") as conn:
                cursor = conn.cursor()

                for product_id in pending_changes[user_id]["to_remove"]:
                    cursor.execute("DELETE FROM my_list WHERE product_id = ?", (product_id,))

                for product_id in pending_changes[user_id]["to_restore"]:
                    cursor.execute("INSERT OR IGNORE INTO my_list (product_id) VALUES (?)", (product_id,))

                conn.commit()

            await callback.answer("–ò–∑–º–µ–Ω–µ–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã", show_alert=True)

            await callback.message.delete()

            await show_my_list_handler(callback)
        else:
            await callback.answer("–ù–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è", show_alert=True)

    except Exception as e:
        await callback.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π", show_alert=True)
    finally:
        pending_changes.pop(user_id, None)


@route.callback_query(F.data == "cancel_changes")
async def cancel_changes_handler(callback: CallbackQuery):
    user_id = callback.from_user.id
    pending_changes.pop(user_id, None)
    await callback.answer("–ò–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω—ã", show_alert=True)
    await callback.message.delete()
    await show_my_list_handler(callback)


@route.callback_query(F.data == "end_search")
async def end_search_handler(callback: CallbackQuery):
    user_id = callback.from_user.id
    pending_changes.pop(user_id, None)
    await callback.message.answer("–ü–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à–µ–Ω", reply_markup=kb.main_kb)
    await callback.answer()

@route.callback_query(F.data.startswith("graph_"))
async def show_price_graph_handler(callback: CallbackQuery):
    try:
        product_id = int(callback.data.split("_")[1])

        with sqlite3.connect("Db/products.db") as conn:
            graph_img, caption = generate_price_graph(conn, product_id)

            if graph_img is None:
                await callback.answer(caption, show_alert=True)
                return

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≥—Ä–∞—Ñ–∏–∫ –±–µ–∑ –∫–Ω–æ–ø–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            await callback.message.answer_photo(
                BufferedInputFile(
                    graph_img.getvalue(),
                    filename="price_graph.png"
                ),
                caption=caption,
                parse_mode="HTML"
            )
            await callback.answer()

    except Exception as e:
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞", show_alert=True)


@route.callback_query(F.data.startswith("notify_"))
async def toggle_notifications(callback: CallbackQuery):
    try:
        product_id = int(callback.data.split("_")[1])

        with sqlite3.connect("Db/products.db") as conn:
            cursor = conn.cursor()

            cursor.execute("SELECT Notice FROM my_list WHERE product_id = ?", (product_id,))
            result = cursor.fetchone()

            if not result:
                await callback.answer("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –≤–∞—à–µ–º —Å–ø–∏—Å–∫–µ", show_alert=True)
                return

            current_status = result[0]
            new_status = 1 if current_status == 0 else 0

            cursor.execute("UPDATE my_list SET Notice = ? WHERE product_id = ?", (new_status, product_id))
            conn.commit()

            notice_icon = "üîî" if new_status == 1 else "üîï"

            new_keyboard = InlineKeyboardMarkup(
                inline_keyboard=[
                    [
                        InlineKeyboardButton(text="‚ùå –£–¥–∞–ª–∏—Ç—å", callback_data=f"mark_remove_{product_id}"),
                        InlineKeyboardButton(text=f"{notice_icon} –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data=f"notify_{product_id}"),
                        InlineKeyboardButton(text="üìà –ò—Å—Ç–æ—Ä–∏—è —Ü–µ–Ω", callback_data=f"graph_{product_id}")
                    ]
                ]
            )

            await callback.message.edit_reply_markup(reply_markup=new_keyboard)
            status_text = "–≤–∫–ª—é—á–µ–Ω—ã" if new_status == 1 else "–æ—Ç–∫–ª—é—á–µ–Ω—ã"
            await callback.answer(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è {status_text}")

    except Exception as e:
        await callback.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π {e}", show_alert=True)

@route.message(F.text == "‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")
async def select_interval(message: Message):
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:",
        reply_markup=kb.get_interval_kb()
    )


@route.message(F.text.regexp(r'^\d+ –¥–Ω–µ–π$'))
async def set_interval(message: Message):
    try:
        days = int(message.text.split()[0])

        with sqlite3.connect("Db/products.db") as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR REPLACE INTO Settings (id, update_interval_days)
                VALUES (1, ?)
            """, (days,))
            conn.commit()

        await message.answer(
            f"‚úÖ –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ {days} –¥–Ω–µ–π",
            reply_markup=kb.settings_kb
        )

    except Exception as e:
        await message.answer(
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞",
            reply_markup=kb.settings_kb
        )